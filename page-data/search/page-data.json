{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"JNI(Java Native Interface)는 자바와 Native Code(C,C++)를 연결하는 데 사용되는 프레임워크이다.\nJNI를 통해 자바 Application에서 Natice Library를 호출하거나, Native Application에서 Java Method를 호출 할 수 있다. 이를 통해, 성능 향상, 기존 Native Library 재…","fields":{"slug":"/JNI/"},"frontmatter":{"date":"July 21, 2024","title":"JNI 사용하기","tags":["Java","JNI"]},"rawMarkdownBody":"JNI(Java Native Interface)는 자바와 Native Code(C,C++)를 연결하는 데 사용되는 프레임워크이다.\nJNI를 통해 자바 Application에서 Natice Library를 호출하거나, Native Application에서 Java Method를 호출 할 수 있다.\n\n이를 통해, 성능 향상, 기존 Native Library 재사용을 할 수 있다.\n\n## 자바에서 사용하는 방법\n\n### Native method\n\n자바는 Method 구현이 native code에서 제공될 것임을 나타내는데 사용되는 native keyword를 제공한다.\n\n공유 라이브러리 : Java 코드 내에서 라이브러리에 대한 참조만 있다. 실행 파일을 실행하는 환경이 프로그램에서 사용하는 libs의 모든 파일에 액세스 할 수 있어야 한다. \n\n공유 라이브러리는 클래스의 일부가 아닌 .so .ddl .dylib 파일 내에 Native Code를 별도로 보관한다.\n\n### 필요 구성요소\n\nJava Code\n\n- Native Keyword : Native로 표시된 모든 method는 native 공유 라이브러리에서 구현되어야 한다.\n- System.loadLibary(String libname) - 공유 라이브러리를 파일 시스템에서 메모리로 로드하고 내보낸 함수를 Java 코드에서 사요할 수 있도록 하는 정적 method\n\n### C/C++ Code\n\n- JNIEXPORT - 함수를 공유 라이브러리에 내보내기 기능으로 표시하여 함수 테이블에 포함되므로 JNI가 찾을 수 있다.\n- JNICALL - JNIEXPORT와 결합 하여 JNI 프레임워크에서 method를 사용할 수 있도록 한다.\n- JNIEnv - Native Code를 사용하여 Java 요소에 액세스 할 수 있는 method가 포함된 구조\n- JavaVM - 실행 중인 JVM을 조작할 수 있는 구조에 Thread를 run/interrupt\n\n이제 코드로 작성해보자\n\n## “Hello World” 출력해보기\n\n### 1. Java Code\n\n```java\npublic class HelloJNI {\n    static {\n        System.loadLibrary(\"JNI_Hello\"); // 네이티브 라이브러리를 로드\n    }\n    \n    public native void printHello(); // 네이티브 메서드 선언\n    \n    public static void main(String[] args) {\n        new HelloJNI().sayHello(); // 네이티브 메서드 호출\n    }\n}\n```\n\nmethod를 선언할 때 `native`  keyword 사용\n\n`printHello`가 호출될 때 자바가 아닌 native로 구현된 method를 찾게 된다.\n\nstatic block은 class가 사용될 때, `JNI_Hello` 이름을 가진 라이브러리를 메모리에 Load한다.\n\n### 2. Java Compiler를 사용하여 Class를 Compile한 후, `javah`를 사용하여 헤더 파일을 생성한다.\n\n```bash\njavac HelloJNI.java\njavah -jni HelloJNI\n```\n\njavah를 사용하여 만들어진 header 파일을 살펴보면 아래 코드와 같다.\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class simple_Hello */\n\n#ifndef _Included_simple_Hello\n#define _Included_simple_Hello\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Class:     simple_Hello\n * Method:    printHello\n * Signature: ()V\n */\n\nJNIEXPORT void JNICALL Java_simple_Hello_printHello(JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\nC파일에 `JNIEXPORT void JNICALL Java_simple_Hello_printHello(JNIEnv *, jobject);`\nMethod를 구현하면 된다. Method이름은 패키지-클래스-메소드 이름으로 되어있다. 따라서 패키지를 java에서 수정하면 native method를 사용하지 못한다.\n\n### 3. C method\n\n```c\n#include <jni.h>\n#include <stdio.h>\n#include \"HelloJNI.h\"\n\nJNIEXPORT void JNICALL Java_simple_Hello_printHello(JNIEnv *env, jobject obj) {\n    printf(\"Hello from C!\\n\");\n}\n```\n\n생성된 헤더 파일을 포함하여 C/C++ 파일을 작성하고 네이티브 메서드를 구현합니다.\n\n### 4. Native Method Compile\n\n작성한 네이티브 코드를 컴파일하여 공유 라이브러리를 생성합니다.\n\n```bash\ngcc -shared -o libhello.so -fPIC HelloJNI.c -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux\n```\n\n### 5. Java Application 실행\n\n```bash\njava -Djava.library.path=. HelloJNI\n```\n\n## Native Library를 Jar파일에 포함하여 Native Method를 사용해보기\n\n위 예제는 서버 배포과정이 아닌 하나의 Java Application을 실행하는데 옵션을 추가하는 건 별 일 아닐 수 있다. 하지만 JNI를 사용하기 위해 서버 배포시 옵션을 추가해주는 일은 번거로운 일이다.\n\n이를 해결하기 위해선 두 가지 문제점을 해결해야 한다.\n\n1. 옵션을 사용하지 않고 Native Library 사용하기\n2. 하나의 Jar 파일만 사용하기\n\n해결 방법은 resources 폴더 내에 Native Library 포함하여 Jar File을 만든 후 Native static block에서 Native Library를 메모리에 Load 하기 전, resource 폴더에서 Native Library 파일을 copy하여 해당 파일을 Native Library를 메모리에 Load 한다. 코드는 아래와 같다.\n\n[How to bundle a native library and a JNI library inside a JAR?](https://stackoverflow.com/questions/2937406/how-to-bundle-a-native-library-and-a-jni-library-inside-a-jar?rq=1)\n\n```java\nString libName = \"libhello.so \"; // The name of the file in resources/ dir\nURL url = MyClass.class.getResource(\"/\" + libName);\nFile tmpDir = Files.createTempDirectory(\"my-native-lib\").toFile();\ntmpDir.deleteOnExit();\nFile nativeLibTmpFile = new File(tmpDir, libName);\nnativeLibTmpFile.deleteOnExit();\ntry (InputStream in = url.openStream()) {\n    Files.copy(in, nativeLibTmpFile.toPath());\n}\nSystem.load(nativeLibTmpFile.getAbsolutePath());\n```\n\n위 코드와 같이 File에 임시로 Native Library를 copy 한 후 load 하는 방식으로 두 가지 문제점을 해결할 수 있었다.\n\n생성된 File은 JVM이 종료되면 삭제된다.\n"},{"excerpt":"DB Process & Thread Oracle Process Process는 OS에 따라 달라진다 오라클 프로세스는 오라클 데이터베이스 코드를 실행하는 실행 단위입니다.\nProcess Architecture (oracle.com) Multiprocess and MultiThread 데이터베이스와 애플리케이션의 작업을 여러 프로세스로 나누면 여러 사용자와…","fields":{"slug":"/OracleProcess/"},"frontmatter":{"date":"July 14, 2024","title":"Oracle Process","tags":["Database","Oracle"]},"rawMarkdownBody":"\n## DB Process & Thread\n\n### Oracle Process\n\n- Process는 OS에 따라 달라진다\n- 오라클 프로세스는 오라클 데이터베이스 코드를 실행하는 실행 단위입니다.\n[Process Architecture (oracle.com)](https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/process-architecture.html#GUID-251AC080-BD5C-415E-8549-B67F8653AD40)\n\n#### Multiprocess and MultiThread\n\n데이터베이스와 애플리케이션의 작업을 여러 프로세스로 나누면 여러 사용자와 애플리케이션이 동시에 인스턴스에 연결할 수 있으며 시스템 성능도 향상됩니다.\n\n쓰레드 모드로 사용하면 일부 프로세스들을 OS 프로세스로 실행 가능하다.\n\nOracle Process ≠ OS Process\n\n### 종류\n\n- Client Process : Application 또는 Oracle Tool 을 실행시킨다.\n    - SQLPlus을 실행시킬 시 OS는 Client Process를 실행시킨다.\n- Background Process : 각 Client Process에 대해 실행 중인 여러 Oracle 프로그램에서 처리할 수 있는 기능을 통합하는 프로세스, 백그라운드 프로세스는 비동기적으로 I/O를 수행하고, 다른 Oracle 프로세스를 모니터링한다.\n- Server Process : 사용자 요청 또는 Client Process 요청을 처리한다.\n\n![OracleStructure](OracleStructure.png)\n\n### Client Process\n\n- ProC Program, SQL Plus 실행 시, OS는 Client Process를 생성한다.\n데이터베이스와 통신하는 데 필요한 API를 제공하는 Oracle 데이터베이스 라이브러리가 연결되어 있습니다.\n- 다른 프로세스들은 SGA를 직접 read, write 할 수 있지만, Client Process는 하지 못한다.\n클라이언트 프로세스는 데이터베이스 호스트가 아닌 다른 호스트에서 실행할 수 있지만 Oracle 프로세스는 그렇지 않습니다.\n\n### Connections and Sessions\n\n- Connection은 Client Process와 데이터베이스 인스턴스 간의 물리적 통신 경로\n- 연결 중에는, IPC 또는 Network Software를 사용할 수 있다.\n- Session은 사용자가 데이터베이스에 의해 인증된 시점부터 사용자가 데이터베이스 애플리케이션 연결을 끊거나 종료할 때까지 지속됩니다.\n\n### Server Process\n\n- 인스턴스에 연결된 클라이언트 프로세스의 요청을 처리하기 위해 서버 프로세스를 생성\n- Client Process는 Server Process를 통해 데이터베이스와 통신한다.\n- Task\n    - 쿼리 계획 생성 및 실행을 포함하여 애플리케이션을 통해 발행된 SQL 문을 구문 분석하고 실행합니다.\n    - PL/SQL 코드 실행\n    - 데이터 파일에서 데이터베이스 버퍼 캐시로 데이터 블록 읽기\n    - Application이 정보를 처리할 수 있는 방식으로 결과를 반환\n\n#### Shared Server Processes\n\n- 여러 Client Process가 하나의 Dispatcher Process에 연결할 수 있다.\n- 연결된 Client의 요청을 수신하여 Pool의 대기열에 넣는다. 사용 가능한 Shared Server가 큐에서 요청을 가져와 처리한다. 그 후 응답 대기열에 결과를 넣는다. Shared Server Process는 큐를 모니터링하고 결과를 클라이언트에게 전송\n\n### Background Process\n\n- 백그라운드 프로세스는 데이터베이스 운영 및 여러 사용자의 성능을 극대화하는 데 필요한 유지 관리 작업을 수행합니다.\n- 각 백그라운드 프로세스에는 별도의 작업이 있지만 다른 프로세스와 함께 작동합니다.\n- 인스턴스 실행 시, 백그라운드 프로세스를 생성한다.\n\n### 필수 Background Process\n\n#### **PMON**\n\n- Process 모니터링 및 Clean up, Buffer Cache , Client Process가 사용하는 자원 관리한다\n- 종료된 프로세스가 보유한 리소스를 다른 프로세스에서 획득할 수 있어야한다.\n    \n    #### **Process Monitor Process (PMON)**\n    \n    - 다른 백그라운드 프로세스의 종료를 감지\n    \n    #### **Cleanup Main Process (CLMN)**\n    \n    - 종료된 프로세스, 종료된 세션, 트랜잭션 등을 정리\n    \n    #### **Cleanup Helper Processes (CLnn)**\n    \n    - 정리 작업 위임받아 실행한다.\n\n#### **Process Manager (PMAN)**\n\n- Shared Server, Pooled Server, Job Queue Process등을 관리한다.\n\n#### **System Monitor Process (SMON)**\n\n- 필요한 경우 인스턴스 시작 시 인스턴스 복구를 수행합니다.\n- 파일 읽기 또는 테이블 스페이스 오프라인 오류로 인해 인스턴스 복구 중에 건너뛴 종료된 트랜잭션을 복구\n- 사용하지 않는 임시 세그먼트를 정리합니다.\n\n#### **Database Writer Process (DBW)**\n\n- 데이터베이스 버퍼의 내용을 데이터 파일에 쓴다.\n- 버퍼 캐시에 있는 수정된 버퍼를 디스크에 쓴다.\n- 대부분 하나의 DBW를 사용하지만, 쓰기 성능을 향상하기 위해 추가 프로세스를 구성할 수 있다.\n단, 단일 프로세스 시스템에선 유효하지 않다.\n- Dirty Buffer를 Disk에 적는 조건\n    - 서버 프로세스가 버퍼를 스캔하는데, 깨끗한 버퍼를 찾지 못한 경우 DBW에 쓰기 신호를 보낸다.\n\n#### **Log Writer Process (LGWR)**\n\n- Online Redo Buffer를 관리한다.\n    - Buffer의 일부분을 Online Redo Log로 write\n- 데이터베이스 버퍼 수정, 디스크 분산 write등 작업을 분리하여 성능 향상\n- 모든 Redo entry들을 버퍼에 write 하는 경우\n    - commit, transaction\n    - log switch 발생 시\n    - Redo log Buffer가 3분의 1이 찼을경우\n\n#### **Checkpoint Process (CKPT)**\n\n- control file, data file header를 체크포인트 정보로 업데이트하고, DBW에 디스크에 write\n- 복구를 시작할 수 있는 Checkpoint 위치, online redo log 위치 포함"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}