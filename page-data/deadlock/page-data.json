{"componentChunkName":"component---src-templates-post-jsx","path":"/deadlock/","result":{"data":{"site":{"siteMetadata":{"title":"Joonsoo"}},"markdownRemark":{"id":"3d90ba69-65a2-5bb9-a515-40c75030341d","excerpt":"이번글은 Oracle Insert 시 발생하는 데드락 문제 분석과 해결 방안에 대해 작성해보았습니다. 데드락이 발생한 상황 가정 상품(Product)과 사은품(Gift) 두 개의 테이블이 있다고 가정해 보겠습니다.\n여기서 상품 테이블의 기본 키(PK)는 사은품 테이블의 기본 키(PK)이자 외래 키(FK)로 설정되어 있으며, 상품 테이블의 PK는 시퀀스(s…","html":"<p>이번글은 Oracle Insert 시 발생하는 데드락 문제 분석과 해결 방안에 대해 작성해보았습니다.</p>\n<h1 id=\"데드락이-발생한-상황-가정\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%9C-%EC%83%81%ED%99%A9-%EA%B0%80%EC%A0%95\" aria-label=\"데드락이 발생한 상황 가정 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>데드락이 발생한 상황 가정</h1>\n<p>상품(Product)과 사은품(Gift) 두 개의 테이블이 있다고 가정해 보겠습니다.\n여기서 상품 테이블의 기본 키(PK)는 사은품 테이블의 기본 키(PK)이자 외래 키(FK)로 설정되어 있으며, 상품 테이블의 PK는 시퀀스(sequence)를 통해 생성됩니다.\n상품 및 사은품 Insert 쿼리는 다음과 같은 흐름으로 이루어집니다.</p>\n<p>아래 흐름은 하나의 트랜잭션에서 동작합니다.</p>\n<ol>\n<li>상품 sequence의 LAST NUMBER로 return id를 지정</li>\n<li>상품 insert. PK는 sequence의 NEXT_VAL로 지정한다.</li>\n<li>1)에서 return_id를 가져와 사은품의 PK로 지정하여 insert.</li>\n</ol>\n<h1 id=\"문제-발견\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EA%B2%AC\" aria-label=\"문제 발견 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문제 발견</h1>\n<p>위와 같은 흐름에서는 데이터의 일관성 문제는 있을 수 있지만, 데드락이 발생하지는 않습니다.\n데드락은 두 개의 트랜잭션이 서로가 보유한 자원을 기다리며 발생하는 상황을 의미합니다.\n위 상황에서 데드락이 발생하지 않는 이유에 대해 알아보겠습니다.\n트랜잭션 1에서 return id를 x, 트랜잭션 2에서 return id를 y라고 가정해보겠습니다.\n트랜잭션 1에서 상품 insert시 실제 저장되는 PK는 x+A, 트랜잭션 2에서 상품 insert시 실제 저장되는 PK는 y+B입니다. (x>0, y>0, A>=0, B>=0)</p>\n<p>트랜잭션 1은 상품 pk가 x+A인 상품을 insert하여 x+A row X lock을 가지고 있고,\n트랜잭션 2은 상품 pk가 y+B인 상품을 insert하여 y+B row X lock을 지닌 상태에서 데드락이 발생할 수 있는 상황은 다음과 같습니다.\n트랜잭션 1에서 사은품 insert시 pk가 x일 경우 참조성 확인을 위해 트랜잭션2의 상품의 pk인 y+B row를 READ, 트랜잭션 2에서 사은품 insert시 pk가 y일 경우 참조성 확인을 위해 트랜잭션1의 상품의 pk인 x+A row READ하는 경우입니다.\n하지만 x = y+B 이며 y = x+A 수식이 성립할 수 없습니다.</p>\n<p>따라서, 상품 한개가 아닌 여러개를 저장하고 3단계에서 return id를 for문을 돌려 사은품의 PK를 (return_id+idx)로 저장하는 상황에서는 데드락이 발생합니다.</p>\n<h1 id=\"문제-해결\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\" aria-label=\"문제 해결 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>문제 해결</h1>\n<p>데드락을 방지하려면, 상품 테이블에 저장된 ID 목록을 한 번에 가져와 사은품 테이블에 Insert하는 방법을 사용해야 합니다.\n하나의 세션에서만 동작하거나 낮은 동시성에서는 문제가 발생하지 않지만, 여러 세션이 동시에 상품을 Insert하게 되면 데드락 발생 가능성이 커집니다.</p>\n<h1 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>결론</h1>\n<p>이번 분석을 통해 Oracle에서도 Insert 과정에서 특정 조건 하에 데드락이 발생할 수 있음을 알게 되었으며, Sequence를 기반으로 PK가 생성되고 여러 종속적 Insert 작업이 있을 경우 데드락 위험이 존재합니다.\n이러한 문제를 인지하고, 관련 레코드를 일괄 Insert하는 방식으로 해결할 수 있습니다.</p>","frontmatter":{"title":"Deadlock in Oracle with Insert query","date":"November 10, 2024","update":"November 10, 2021","tags":["Oracle","Deadlock"],"series":null},"fields":{"slug":"/deadlock/","readingTime":{"minutes":4.365}}},"seriesList":{"edges":[{"node":{"id":"19c4b28f-bf7a-5cdd-9147-4a1b01bbe394","fields":{"slug":"/OracleProcess/"},"frontmatter":{"title":"Oracle Process"}}},{"node":{"id":"3257ffa6-9029-5b52-8a00-19d7c96245fb","fields":{"slug":"/JNI/"},"frontmatter":{"title":"JNI 사용하기"}}},{"node":{"id":"c8d5ffe4-16ca-5cc6-b9a6-be881cbd11d1","fields":{"slug":"/blkid/"},"frontmatter":{"title":"blkid를 활용하여 Mount시 Volume 고정하기"}}},{"node":{"id":"9318cb63-9840-5577-a536-f9e27120b86d","fields":{"slug":"/AbstractFactoryPatternStrategyPattern/"},"frontmatter":{"title":"추상 팩토리 패턴과 전략패턴 활용"}}},{"node":{"id":"4c38ac2d-b026-5a88-8557-93fb79b777ad","fields":{"slug":"/ConnectionPool/"},"frontmatter":{"title":"Connection Pool"}}},{"node":{"id":"3d90ba69-65a2-5bb9-a515-40c75030341d","fields":{"slug":"/deadlock/"},"frontmatter":{"title":"Deadlock in Oracle with Insert query"}}}]},"previous":{"fields":{"slug":"/ConnectionPool/"},"frontmatter":{"title":"Connection Pool"}},"next":null},"pageContext":{"id":"3d90ba69-65a2-5bb9-a515-40c75030341d","series":null,"previousPostId":"4c38ac2d-b026-5a88-8557-93fb79b777ad","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}